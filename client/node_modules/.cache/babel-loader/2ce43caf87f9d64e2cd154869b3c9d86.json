{"ast":null,"code":"(function ($) {\n  \"use strict\";\n\n  const wrapperName = \"explode-wrapper\";\n\n  if (!$) {\n    console.error(\"jQuery or Zepto is needed.\");\n    return;\n  }\n\n  $.fn.explodeRestore = function () {\n    this.each(function () {\n      //restore separately\n      const $dom = $(this);\n      const wrapper = $dom.prop(wrapperName);\n\n      if (wrapper) {\n        wrapper.replaceWith($dom);\n        $dom.prop(wrapperName, null);\n      }\n    });\n  };\n\n  $.fn.explode = function (opt) {\n    if (!opt || typeof opt !== \"object\") {\n      opt = {};\n    }\n\n    const {\n      minWidth = 3,\n      omitLastLine = false,\n      radius = 80,\n      minRadius = 0,\n      release = true,\n      fadeTime = 300,\n      recycle = true,\n      recycleDelay = 500,\n      fill = true,\n      explodeTime = 300,\n      maxAngle = 360,\n      gravity = 0,\n      round = false,\n      groundDistance = 400,\n      land = true,\n      checkOutBound,\n      finish\n    } = opt;\n    let {\n      maxWidth\n    } = opt;\n    const $target = this;\n    let $targetImage;\n    const args = arguments;\n\n    if ($target.length > 1) {\n      //explode separately\n      $target.each(function () {\n        const $dom = $(this);\n        $dom.explode.apply($dom, args);\n      });\n      return;\n    } else if (!$target.length) {\n      return;\n    }\n\n    if (!$.contains(document, $target[0])) {\n      return;\n    }\n\n    if ($target.prop(\"tagName\") === \"IMG\") {\n      if (!$target.prop(\"complete\")) {\n        $target.on(\"load\", function () {\n          $target.explode.apply($target, args);\n        });\n        return;\n      }\n\n      $targetImage = $target;\n    } else if ($target.css(\"backgroundImage\") !== \"none\") {\n      const src = $target.css(\"backgroundImage\").match(/url\\(\\\"([\\S\\s]*)\\\"\\)/)[1];\n      $targetImage = $(\"<img/>\", {\n        src\n      });\n\n      if (!opt.ignoreCompelete) {\n        $targetImage.on(\"load\", function () {\n          opt.ignoreCompelete = true;\n          $target.explode.apply($target, [opt]);\n        });\n        return;\n      }\n    }\n\n    const w = $target.width();\n    const h = $target.height();\n    const minorDimension = Math.min(w, h);\n    const radiusData = getRadiusData();\n    const ctxWidth = Math.max(w, radius * 2);\n    const ctxHeight = Math.max(h, radius * 2, groundDistance * 2);\n\n    if (!maxWidth) {\n      maxWidth = minorDimension / 4;\n    }\n\n    const $wrapper = $(\"<div></div>\", {\n      \"class\": wrapperName\n    });\n    const syncStyles = [\"width\", \"height\", \"margin-top\", \"margin-right\", \"margin-bottom\", \"margin-left\", \"position\", \"top\", \"right\", \"bottom\", \"left\", \"float\", \"display\"];\n    syncStyles.forEach(v => {\n      $wrapper.css(v, $target.css(v));\n    }); //        $wrapper.css(\"background-color\", \"black\");\n\n    if ($wrapper.css(\"position\") === \"static\") {\n      $wrapper.css(\"position\", \"relative\");\n    }\n\n    const startRatio = 0.3; //generate rags' body\n\n    const rags = generateRags();\n    getRagsFinalState();\n    const $canvas = $(\"<canvas></canvas>\"); //standard canvas, to draw the ideal target\n\n    const $canvas0 = $(\"<canvas></canvas>\");\n    $canvas0.css({\n      width: w,\n      height: h\n    });\n    $canvas0.attr({\n      width: w,\n      height: h\n    });\n    $canvas.css({\n      position: \"absolute\",\n      left: (w - ctxWidth) / 2,\n      right: (w - ctxWidth) / 2,\n      top: (h - ctxHeight) / 2,\n      bottom: (h - ctxHeight) / 2,\n      margin: \"auto\",\n      width: ctxWidth,\n      height: ctxHeight\n    });\n    $canvas.attr({\n      width: ctxWidth,\n      height: ctxHeight\n    });\n    $wrapper.append($canvas);\n    const ctx = $canvas[0].getContext(\"2d\");\n    const ctx0 = $canvas0[0].getContext(\"2d\");\n\n    function warn(key, config) {\n      console.warn(`Unsupported ${key} style:${config[key]}`);\n    }\n\n    const {\n      naturalWidth,\n      naturalHeight\n    } = $targetImage ? $targetImage[0] : {};\n\n    if ($target.prop(\"tagName\") === \"IMG\") {\n      ctx0.drawImage($targetImage[0], 0, 0, naturalWidth, naturalHeight, 0, 0, w, h);\n    } else if ($target.css(\"backgroundImage\") !== \"none\") {\n      let dx = 0,\n          dy = 0,\n          dWidth = naturalWidth,\n          dHeight = naturalHeight;\n      let config = {\n        \"background-repeat\": $target.css(\"background-repeat\"),\n        \"background-size\": $target.css(\"background-size\"),\n        \"background-position-x\": $target.css(\"background-position-x\"),\n        \"background-position-y\": $target.css(\"background-position-y\")\n      };\n      const ratioW = w / naturalWidth;\n      const ratioH = h / naturalHeight;\n\n      if (config[\"background-size\"] === \"cover\") {\n        const ratio = Math.max(ratioW, ratioH);\n        dWidth = naturalWidth * ratio;\n        dHeight = naturalHeight * ratio;\n      } else if (config[\"background-size\"] === \"contain\") {\n        const ratio = Math.min(ratioW, ratioH);\n        dWidth = naturalWidth * ratio;\n        dHeight = naturalHeight * ratio;\n      } else {\n        warn(\"background-size\", config);\n      }\n\n      dx = parseInt(config[\"background-position-x\"]) / 100 * (w - dWidth);\n      dy = parseInt(config[\"background-position-y\"]) / 100 * (h - dHeight);\n\n      if (config[\"background-repeat\"] === \"repeat\") {\n        for (var i = 0 - Math.ceil(dx / dWidth); i < w / dWidth + Math.ceil(-dx / dWidth); i++) {\n          for (var j = 0 - Math.ceil(dy / dHeight); j < h / dHeight + Math.ceil(-dy / dHeight); j++) {\n            ctx0.drawImage($targetImage[0], 0, 0, naturalWidth, naturalHeight, dx + i * dWidth, dy + j * dHeight, dWidth, dHeight);\n          }\n        }\n      } else if (config[\"background-repeat\"] === \"no-repeat\") {\n        ctx0.drawImage($targetImage[0], 0, 0, naturalWidth, naturalHeight, dx, dy, dWidth, dHeight);\n      } else {\n        warn(\"background-repeat\", config);\n      }\n    } else if ($target.css(\"backgroundColor\") !== \"rgba(0, 0, 0, 0)\") {\n      ctx0.fillStyle = $target.css(\"backgroundColor\");\n      ctx0.fillRect(0, 0, w, h);\n    } else {\n      console.warn(\"There's nothing to explode.\");\n    }\n\n    rags.forEach(rag => {\n      const {\n        left,\n        top,\n        width: ragWidth,\n        height: ragHeight\n      } = rag;\n      rag.naturalParams = [left, top, ragWidth, ragHeight];\n    });\n    $target.after($wrapper);\n    $target.prop(wrapperName, $wrapper);\n    $target.detach();\n    let biasVy = 0;\n    explode(function () {\n      if (release) {\n        doRelease();\n      } else if (recycle) {\n        doRecycle();\n      } else {\n        finish && finish();\n      }\n    });\n\n    function doRelease(cb) {\n      const startTime = Date.now();\n      let leftCnt = rags.length;\n      rags.forEach(rag => {\n        rag.time1 = 1000 / (rag.ratio * (maxWidth + 1 - rag.width) / maxWidth + 0.1);\n        rag.time2 = rag.time1 + fadeTime;\n      });\n      draw();\n\n      function draw() {\n        const time = Date.now();\n        const duration = time - startTime;\n        ctx.clearRect(0, 0, ctxWidth, ctxHeight);\n        rags.forEach(rag => {\n          ctx.save();\n          const {\n            width: ragWidth,\n            height: ragHeight\n          } = rag;\n          ctx.translate(rag.biasx, rag.biasy);\n          ctx.rotate(rag.lastAngle || rag.finalAngleRad);\n\n          if (round) {\n            ctx.beginPath();\n            ctx.arc(0, 0, ragWidth / 2, 0, Math.PI * 2, false);\n            ctx.closePath();\n            ctx.clip();\n          }\n\n          let alpha;\n\n          if (duration < rag.time1) {\n            alpha = 1;\n          } else if (duration > rag.time2) {\n            alpha = 0;\n          } else {\n            alpha = 1 - (duration - rag.time1) / fadeTime;\n          }\n\n          if (alpha === 0 && !rag.released) {\n            rag.released = true;\n            leftCnt--;\n          }\n\n          ctx.globalAlpha = alpha;\n          ctx.drawImage($canvas0[0], rag.left, rag.top, rag.width, rag.height, -ragWidth / 2, -ragHeight / 2, ragWidth, ragHeight);\n          ctx.restore();\n        });\n\n        if (!leftCnt) {\n          cb && cb();\n        } else {\n          window.requestAnimationFrame(draw);\n        }\n      }\n    }\n\n    function doRecycle() {\n      setTimeout(function () {\n        explode(function () {\n          $target.explodeRestore();\n        }, true);\n      }, recycleDelay);\n    }\n\n    function explode(cb, reverse) {\n      const startTime = Date.now();\n      let lastTime = startTime;\n      let leftCnt = rags.length;\n\n      if (!reverse) {\n        rags.forEach(rag => {\n          rag.vx = rag.translateX / explodeTime * 1000;\n          rag.vy = rag.translateY / explodeTime * 1000;\n          rag.biasx = rag.translateX0;\n          rag.biasy = rag.translateY0;\n\n          if (gravity) {\n            rag.transYMax = ctxHeight / 2 + groundDistance - rag.height / 2;\n          }\n        });\n      }\n\n      draw();\n\n      function draw() {\n        const time = Date.now();\n        let ratio;\n        let angleRatio;\n        ratio = (time - lastTime) / 1000;\n        angleRatio = (time - startTime) / explodeTime;\n\n        if (reverse) {\n          angleRatio = 1 - angleRatio;\n        }\n\n        if (gravity) {\n          biasVy += gravity * ratio * 300;\n        } else {\n          if (angleRatio > 1 || angleRatio < 0) {\n            cb && cb();\n            return;\n          }\n\n          ratio *= Math.cos(angleRatio * Math.PI / 2) * Math.PI / 2;\n        }\n\n        if (reverse) {\n          ratio = -ratio;\n        }\n\n        lastTime = time;\n        ctx.clearRect(0, 0, ctxWidth, ctxHeight);\n        rags.forEach(rag => {\n          ctx.save();\n          const {\n            width: ragWidth,\n            height: ragHeight\n          } = rag;\n\n          if (!rag.land) {\n            rag.biasx += rag.vx * ratio;\n            rag.biasy += (rag.vy + biasVy) * ratio;\n\n            if (gravity) {\n              if (checkOutBound && checkOutBound(rag) || rag.biasy > rag.transYMax || rag.biasy < rag.height / 2) {\n                leftCnt--;\n                rag.land = true;\n                rag.lastAngle = rag.finalAngleRad * angleRatio;\n\n                if (land) {\n                  rag.biasy = gravity > 0 ? rag.transYMax : rag.height / 2;\n                } else {\n                  rag.biasy = rag.transYMax * 2; //hide\n                }\n              }\n            }\n          }\n\n          ctx.translate(rag.biasx, rag.biasy);\n\n          if (rag.lastAngle) {\n            ctx.rotate(rag.lastAngle);\n          } else {\n            ctx.rotate(rag.finalAngleRad * angleRatio);\n          }\n\n          if (round) {\n            ctx.beginPath();\n            ctx.arc(0, 0, ragWidth / 2, 0, Math.PI * 2, false);\n            ctx.closePath();\n            ctx.clip();\n          }\n\n          ctx.drawImage($canvas0[0], rag.left, rag.top, rag.width, rag.height, -ragWidth / 2, -ragHeight / 2, ragWidth, ragHeight);\n          ctx.restore();\n        });\n\n        if (gravity && !leftCnt) {\n          cb();\n        } else {\n          window.requestAnimationFrame(draw);\n        }\n      }\n    }\n\n    function random(min, max) {\n      return parseInt(Math.random() * (max + 1 - min), 10) + min;\n    }\n\n    function shuffle(array) {\n      let currentIndex = array.length,\n          temporaryValue,\n          randomIndex;\n\n      while (currentIndex) {\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n        temporaryValue = array[currentIndex];\n        array[currentIndex] = array[randomIndex];\n        array[randomIndex] = temporaryValue;\n      }\n\n      return array;\n    } //generate final position and angle of rags\n\n\n    function getRagsFinalState() {\n      rags.forEach((v, i) => {\n        const finalAngle = (Math.random() * maxAngle * 2 - maxAngle) / ((Math.random() + 2) * v.width) * 10; //coordinate based on center point\n\n        let x = v.left + v.width / 2 - w / 2;\n        let y = v.top + v.width / 2 - h / 2;\n\n        if (x === 0) {\n          x = i % 2 ? -1 : 1;\n        }\n\n        if (y === 0) {\n          y = i % 4 < 2 ? -1 : 1;\n        }\n\n        const distance = Math.sqrt(x * x + y * y);\n        let ratio = ((1 - startRatio) * (1 - (v.width - minWidth) / (maxWidth - minWidth)) + startRatio) * Math.random();\n        ratio = 1 - (1 - ratio) * (1 - minRadius / radius);\n        const finalDistance = (radius - distance) * ratio + distance;\n        const distanceSquare = distance * distance;\n        const attach = {\n          finalDistance,\n          ratio,\n          x,\n          y,\n          distance,\n          translateX: (finalDistance - distance) * Math.sqrt((distanceSquare - y * y) / distanceSquare) * (x > 0 ? 1 : -1),\n          translateY: (finalDistance - distance) * Math.sqrt((distanceSquare - x * x) / distanceSquare) * (y > 0 ? 1 : -1),\n          translateX0: (ctxWidth - w) / 2 + v.left + v.width / 2,\n          translateY0: (ctxHeight - h) / 2 + v.top + v.height / 2,\n          finalAngle,\n          finalAngleRad: finalAngle * (Math.PI / 180)\n        };\n\n        for (let i in attach) {\n          v[i] = attach[i];\n        }\n      });\n    } //generate inital position and dimension of rags\n    //rewrite it to fit for you demand\n\n\n    function generateRags() {\n      let rowCnt;\n      const base = [[0, 1], [1, 1], [1, 0], [0, 0]];\n\n      if (omitLastLine) {\n        rowCnt = Math.floor(h / maxWidth);\n      } else {\n        rowCnt = Math.ceil(h / maxWidth);\n      }\n\n      const rags = [];\n      const noRadius = radiusData.every(function (v) {\n        return v === 0;\n      });\n\n      for (let row = 0; row < rowCnt; row++) {\n        generateRow(row);\n      }\n\n      function isInner(x, y) {\n        if (x < radiusData[0] && y > h - radiusData[0] || x > w - radiusData[1] && y > h - radiusData[1] || x > w - radiusData[2] && y < radiusData[2] || x < radiusData[3] && y < radiusData[3]) {\n          return false;\n        }\n\n        return true;\n      }\n\n      function distanceLessThan(x1, y1, x2, y2, d) {\n        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) < d * d;\n      }\n\n      function tryPushRag({\n        left,\n        top,\n        width,\n        height\n      }) {\n        const x = left + width / 2;\n        const y = h - top - height / 2;\n\n        if (noRadius || isInner(x, y) || radiusData.some(function (v, i) {\n          return distanceLessThan(x, y, base[i][0] * w + 2 * (0.5 - base[i][0]) * v, base[i][1] * h + 2 * (0.5 - base[i][1]) * v, v);\n        })) {\n          rags.push({\n            left,\n            top,\n            width,\n            height\n          });\n        }\n      }\n\n      function generateRow(row) {\n        let rowSum = 0;\n        const topBase = row * maxWidth;\n\n        function generate(width) {\n          const left = rowSum;\n          rowSum += width;\n          tryPushRag({\n            left,\n            top: topBase,\n            width,\n            height: width\n          });\n\n          if (fill) {\n            for (let i = 1; i < parseInt(maxWidth / width); i++) {\n              tryPushRag({\n                left,\n                top: topBase + i * width,\n                width,\n                height: width\n              });\n            }\n          }\n        }\n\n        let width;\n\n        do {\n          if (width) {\n            generate(width);\n          }\n\n          width = random(minWidth, maxWidth);\n        } while (w > rowSum + width);\n\n        if (w - rowSum >= minWidth) {\n          generate(w - rowSum);\n        }\n      }\n\n      shuffle(rags);\n      return rags;\n    } //get an array of 4 corners of radius        \n\n\n    function getRadiusData() {\n      let ret = [\"border-top-left-radius\", \"border-top-right-radius\", \"border-bottom-right-radius\", \"border-bottom-left-radius\"];\n      const width = $target.width();\n      ret = ret.map(function (key) {\n        let radius = $target.css(key);\n\n        if (radius.match(/px$/)) {\n          return radius.match(/^\\d+/)[0] * 1;\n        } else if (radius.match(/%$/)) {\n          return radius.match(/^\\d+/)[0] / 100 * width;\n        }\n\n        return radius;\n      });\n      ret = ret.map(function (radius) {\n        if (radius > width / 2) {\n          radius = width / 2;\n        }\n\n        return radius;\n      });\n      return ret;\n    }\n  };\n})(window.jQuery || window.Zepto);","map":{"version":3,"sources":["C:/MERN Projects/BombParty/bombparty/client/src/components/Game/js/img-explode.js"],"names":["$","wrapperName","console","error","fn","explodeRestore","each","$dom","wrapper","prop","replaceWith","explode","opt","minWidth","omitLastLine","radius","minRadius","release","fadeTime","recycle","recycleDelay","fill","explodeTime","maxAngle","gravity","round","groundDistance","land","checkOutBound","finish","maxWidth","$target","$targetImage","args","arguments","length","apply","contains","document","on","css","src","match","ignoreCompelete","w","width","h","height","minorDimension","Math","min","radiusData","getRadiusData","ctxWidth","max","ctxHeight","$wrapper","syncStyles","forEach","v","startRatio","rags","generateRags","getRagsFinalState","$canvas","$canvas0","attr","position","left","right","top","bottom","margin","append","ctx","getContext","ctx0","warn","key","config","naturalWidth","naturalHeight","drawImage","dx","dy","dWidth","dHeight","ratioW","ratioH","ratio","parseInt","i","ceil","j","fillStyle","fillRect","rag","ragWidth","ragHeight","naturalParams","after","detach","biasVy","doRelease","doRecycle","cb","startTime","Date","now","leftCnt","time1","time2","draw","time","duration","clearRect","save","translate","biasx","biasy","rotate","lastAngle","finalAngleRad","beginPath","arc","PI","closePath","clip","alpha","released","globalAlpha","restore","window","requestAnimationFrame","setTimeout","reverse","lastTime","vx","translateX","vy","translateY","translateX0","translateY0","transYMax","angleRatio","cos","random","shuffle","array","currentIndex","temporaryValue","randomIndex","floor","finalAngle","x","y","distance","sqrt","finalDistance","distanceSquare","attach","rowCnt","base","noRadius","every","row","generateRow","isInner","distanceLessThan","x1","y1","x2","y2","d","tryPushRag","some","push","rowSum","topBase","generate","ret","map","jQuery","Zepto"],"mappings":"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","sourcesContent":["(function ($) {\r\n    \"use strict\";\r\n    const wrapperName = \"explode-wrapper\";\r\n    if(!$){\r\n        console.error(\"jQuery or Zepto is needed.\");\r\n        return;\r\n    }\r\n    $.fn.explodeRestore = function () {\r\n        this.each(function () { //restore separately\r\n            const $dom = $(this);\r\n            const wrapper = $dom.prop(wrapperName);\r\n            if (wrapper) {\r\n                wrapper.replaceWith($dom);\r\n                $dom.prop(wrapperName, null);\r\n            }\r\n        });\r\n    };\r\n    $.fn.explode = function (opt) {\r\n        if (!opt || typeof opt !== \"object\") {\r\n            opt = {};\r\n        }\r\n\r\n        const {\r\n            minWidth = 3,\r\n                omitLastLine = false,\r\n                radius = 80,\r\n                minRadius = 0,\r\n                release = true,\r\n                fadeTime = 300,\r\n                recycle = true,\r\n                recycleDelay = 500,\r\n                fill = true,\r\n                explodeTime = 300,\r\n                maxAngle = 360,\r\n                gravity = 0,\r\n                round = false,\r\n                groundDistance = 400,\r\n                land=true,\r\n                checkOutBound,\r\n                finish,\r\n        } = opt;\r\n\r\n        let {\r\n            maxWidth\r\n        } = opt;\r\n\r\n        const $target = this;\r\n        let $targetImage;\r\n        const args = arguments;\r\n        if ($target.length > 1) { //explode separately\r\n            $target.each(function () {\r\n                const $dom = $(this);\r\n                $dom.explode.apply($dom, args);\r\n            });\r\n            return;\r\n        } else if (!$target.length) {\r\n            return;\r\n        }\r\n        if(!$.contains(document,$target[0])){\r\n            return ;\r\n        }\r\n        if ($target.prop(\"tagName\") === \"IMG\") {\r\n            if (!$target.prop(\"complete\")) {\r\n\r\n                $target.on(\"load\", function () {\r\n                    $target.explode.apply($target, args);\r\n                });\r\n                return;\r\n            }\r\n            $targetImage = $target;\r\n        } else if ($target.css(\"backgroundImage\") !== \"none\") {\r\n\r\n            const src = $target.css(\"backgroundImage\").match(/url\\(\\\"([\\S\\s]*)\\\"\\)/)[1];\r\n            $targetImage = $(\"<img/>\", {\r\n                src\r\n            });\r\n            if (!opt.ignoreCompelete) {\r\n                $targetImage.on(\"load\", function () {\r\n                    opt.ignoreCompelete = true;\r\n                    $target.explode.apply($target, [opt]);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n\r\n        const w = $target.width();\r\n        const h = $target.height();\r\n        const minorDimension = Math.min(w, h);\r\n        const radiusData = getRadiusData();\r\n\r\n        const ctxWidth = Math.max(w, radius * 2);\r\n        const ctxHeight = Math.max(h, radius * 2, groundDistance * 2);\r\n        if (!maxWidth) {\r\n            maxWidth = minorDimension / 4;\r\n        }\r\n        const $wrapper = $(\"<div></div>\", {\r\n            \"class\": wrapperName,\r\n        });\r\n        const syncStyles = [\"width\", \"height\", \"margin-top\", \"margin-right\", \"margin-bottom\", \"margin-left\", \"position\", \"top\", \"right\", \"bottom\", \"left\", \"float\", \"display\"];\r\n        syncStyles.forEach((v) => {\r\n            $wrapper.css(v, $target.css(v));\r\n        });\r\n        //        $wrapper.css(\"background-color\", \"black\");\r\n        if ($wrapper.css(\"position\") === \"static\") {\r\n            $wrapper.css(\"position\", \"relative\");\r\n        }\r\n\r\n        const startRatio = 0.3;\r\n\r\n        //generate rags' body\r\n        const rags = generateRags();\r\n        getRagsFinalState();\r\n\r\n        const $canvas = $(\"<canvas></canvas>\");\r\n\r\n        //standard canvas, to draw the ideal target\r\n        const $canvas0 = $(\"<canvas></canvas>\");\r\n        $canvas0.css({\r\n            width: w,\r\n            height: h,\r\n        });\r\n        $canvas0.attr({\r\n            width: w,\r\n            height: h,\r\n        });\r\n\r\n        $canvas.css({\r\n            position: \"absolute\",\r\n            left: (w - ctxWidth) / 2,\r\n            right: (w - ctxWidth) / 2,\r\n            top: (h - ctxHeight) / 2,\r\n            bottom: (h - ctxHeight) / 2,\r\n            margin: \"auto\",\r\n            width: ctxWidth,\r\n            height: ctxHeight,\r\n        });\r\n        $canvas.attr({\r\n            width: ctxWidth,\r\n            height: ctxHeight,\r\n        });\r\n\r\n        $wrapper.append($canvas);\r\n\r\n        const ctx = $canvas[0].getContext(\"2d\");\r\n        const ctx0 = $canvas0[0].getContext(\"2d\");\r\n        function warn(key,config) {\r\n            console.warn(`Unsupported ${key} style:${config[key]}`);\r\n        }\r\n        const {\r\n            naturalWidth,\r\n            naturalHeight\r\n        } = $targetImage?$targetImage[0]:{};\r\n        if ($target.prop(\"tagName\") === \"IMG\") {\r\n            ctx0.drawImage($targetImage[0], 0, 0, naturalWidth, naturalHeight, 0, 0, w, h);\r\n        } else if ($target.css(\"backgroundImage\") !== \"none\") {\r\n            let dx = 0,\r\n                dy = 0,\r\n                dWidth = naturalWidth,\r\n                dHeight = naturalHeight;\r\n            let config = {\r\n                \"background-repeat\": $target.css(\"background-repeat\"),\r\n                \"background-size\": $target.css(\"background-size\"),\r\n                \"background-position-x\": $target.css(\"background-position-x\"),\r\n                \"background-position-y\": $target.css(\"background-position-y\"),\r\n            };\r\n\r\n            \r\n            const ratioW = w / naturalWidth;\r\n            const ratioH = h / naturalHeight;\r\n\r\n\r\n            if (config[\"background-size\"] === \"cover\") {\r\n                const ratio = Math.max(ratioW, ratioH);\r\n\r\n                dWidth = naturalWidth * ratio;\r\n                dHeight = naturalHeight * ratio;\r\n            } else if (config[\"background-size\"] === \"contain\") {\r\n                const ratio = Math.min(ratioW, ratioH);\r\n\r\n                dWidth = naturalWidth * ratio;\r\n                dHeight = naturalHeight * ratio;\r\n            } else {\r\n                warn(\"background-size\",config);\r\n\r\n            }\r\n            dx = parseInt(config[\"background-position-x\"]) / 100 * (w - dWidth);\r\n            dy = parseInt(config[\"background-position-y\"]) / 100 * (h - dHeight);\r\n\r\n            if (config[\"background-repeat\"] === \"repeat\") {\r\n                for (var i = 0 - Math.ceil(dx / dWidth); i < w / dWidth + Math.ceil(-dx / dWidth); i++) {\r\n                    for (var j = 0 - Math.ceil(dy / dHeight); j < h / dHeight + Math.ceil(-dy / dHeight); j++) {\r\n                        ctx0.drawImage($targetImage[0], 0, 0, naturalWidth, naturalHeight, dx + i * dWidth, dy + j * dHeight, dWidth, dHeight);\r\n                    }\r\n                }\r\n            } else if (config[\"background-repeat\"] === \"no-repeat\") {\r\n                ctx0.drawImage($targetImage[0], 0, 0, naturalWidth, naturalHeight, dx, dy, dWidth, dHeight);\r\n            } else {\r\n                warn(\"background-repeat\",config);\r\n            }\r\n\r\n        } else if ($target.css(\"backgroundColor\") !== \"rgba(0, 0, 0, 0)\") {\r\n            ctx0.fillStyle = $target.css(\"backgroundColor\");\r\n            ctx0.fillRect(0, 0, w, h);\r\n        } else {\r\n            console.warn(\"There's nothing to explode.\");\r\n        }\r\n\r\n        rags.forEach((rag) => {\r\n            const {\r\n                left,\r\n                top,\r\n                width: ragWidth,\r\n                height: ragHeight,\r\n            } = rag;\r\n\r\n            rag.naturalParams = [left, top, ragWidth, ragHeight];\r\n        });\r\n\r\n        $target.after($wrapper);\r\n        $target.prop(wrapperName, $wrapper);\r\n        $target.detach();\r\n\r\n        let biasVy = 0;\r\n\r\n        explode(function () {\r\n            if (release) {\r\n                doRelease();\r\n            } else if (recycle) {\r\n                doRecycle();\r\n            }else{\r\n                finish&&finish();\r\n            }\r\n        });\r\n        \r\n        function doRelease(cb) {\r\n            const startTime = Date.now();\r\n            let leftCnt = rags.length;\r\n\r\n            rags.forEach((rag) => {\r\n                rag.time1 = 1000 / (rag.ratio * (maxWidth + 1 - rag.width) / maxWidth + 0.1);\r\n                rag.time2 = rag.time1 + fadeTime;\r\n            });\r\n            draw();\r\n\r\n            function draw() {\r\n                const time = Date.now();\r\n                const duration = time - startTime;\r\n\r\n                ctx.clearRect(0, 0, ctxWidth, ctxHeight);\r\n\r\n                rags.forEach((rag) => {\r\n                    ctx.save();\r\n                    const {\r\n                        width: ragWidth,\r\n                        height: ragHeight,\r\n                    } = rag;\r\n\r\n                    ctx.translate(rag.biasx, rag.biasy);\r\n\r\n                    ctx.rotate(rag.lastAngle || rag.finalAngleRad);\r\n\r\n                    if (round) {\r\n                        ctx.beginPath();\r\n                        ctx.arc(0, 0, ragWidth / 2, 0, Math.PI * 2, false);\r\n                        ctx.closePath();\r\n                        ctx.clip();\r\n                    }\r\n                    let alpha;\r\n                    if (duration < rag.time1) {\r\n                        alpha = 1;\r\n                    } else if (duration > rag.time2) {\r\n                        alpha = 0;\r\n                    } else {\r\n                        alpha = 1 - (duration - rag.time1) / fadeTime;\r\n                    }\r\n                    if (alpha === 0 && !rag.released) {\r\n                        rag.released = true;\r\n                        leftCnt--;\r\n                    }\r\n                    ctx.globalAlpha = alpha;\r\n                    ctx.drawImage($canvas0[0], rag.left, rag.top, rag.width, rag.height, -ragWidth / 2, -ragHeight / 2, ragWidth, ragHeight);\r\n                    ctx.restore();\r\n                });\r\n                if (!leftCnt) {\r\n                    cb && cb();\r\n                } else {\r\n                    window.requestAnimationFrame(draw);\r\n                }\r\n            }\r\n        }\r\n\r\n        function doRecycle() {\r\n            setTimeout(function () {\r\n                explode(function () {\r\n                    $target.explodeRestore();\r\n                }, true);\r\n            }, recycleDelay);\r\n\r\n        }\r\n\r\n\r\n\r\n        function explode(cb, reverse) {\r\n            const startTime = Date.now();\r\n            let lastTime = startTime;\r\n            let leftCnt = rags.length;\r\n\r\n            if (!reverse) {\r\n                rags.forEach((rag) => {\r\n                    rag.vx = rag.translateX / explodeTime * 1000;\r\n                    rag.vy = rag.translateY / explodeTime * 1000;\r\n\r\n                    rag.biasx = rag.translateX0;\r\n                    rag.biasy = rag.translateY0;\r\n                    if (gravity) {\r\n                        rag.transYMax = ctxHeight / 2 + groundDistance - rag.height / 2;\r\n                    }\r\n\r\n                });\r\n            }\r\n\r\n            draw();\r\n\r\n            function draw() {\r\n                const time = Date.now();\r\n                let ratio;\r\n                let angleRatio;\r\n                ratio = (time - lastTime) / 1000;\r\n                angleRatio = (time - startTime) / explodeTime;\r\n                if (reverse) {\r\n                    angleRatio = 1 - angleRatio;\r\n                }\r\n                if (gravity) {\r\n                    biasVy += (gravity * ratio) * 300;\r\n                } else {\r\n                    if (angleRatio > 1 || angleRatio < 0) {\r\n                        cb && cb();\r\n                        return;\r\n                    }\r\n                    ratio *= Math.cos(angleRatio * Math.PI / 2) * Math.PI / 2;\r\n                }\r\n                if (reverse) {\r\n                    ratio = -ratio;\r\n                }\r\n                lastTime = time;\r\n                ctx.clearRect(0, 0, ctxWidth, ctxHeight);\r\n                rags.forEach((rag) => {\r\n                    ctx.save();\r\n                    const {\r\n                        width: ragWidth,\r\n                        height: ragHeight,\r\n                    } = rag;\r\n\r\n                    if (!rag.land) {\r\n                        rag.biasx += rag.vx * ratio;\r\n                        rag.biasy += (rag.vy + biasVy) * ratio;\r\n\r\n                        if (gravity) {\r\n                            if (checkOutBound && checkOutBound(rag) \r\n                                || rag.biasy > rag.transYMax\r\n                               || rag.biasy < rag.height/2) {\r\n                                leftCnt--;\r\n                                rag.land = true;\r\n                                rag.lastAngle = rag.finalAngleRad * angleRatio;\r\n                                \r\n                                if(land){\r\n                                    rag.biasy = gravity>0?rag.transYMax:rag.height/2;\r\n                                }else{\r\n                                    rag.biasy=rag.transYMax*2;//hide\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    }\r\n\r\n                    ctx.translate(rag.biasx, rag.biasy);\r\n\r\n                    if (rag.lastAngle) {\r\n                        ctx.rotate(rag.lastAngle);\r\n                    } else {\r\n                        ctx.rotate(rag.finalAngleRad * angleRatio);\r\n                    }\r\n\r\n                    if (round) {\r\n                        ctx.beginPath();\r\n                        ctx.arc(0, 0, ragWidth / 2, 0, Math.PI * 2, false);\r\n                        ctx.closePath();\r\n                        ctx.clip();\r\n                    }\r\n\r\n                    ctx.drawImage($canvas0[0], rag.left, rag.top, rag.width, rag.height, -ragWidth / 2, -ragHeight / 2, ragWidth, ragHeight);\r\n                    ctx.restore();\r\n                });\r\n                if (gravity && !leftCnt) {\r\n                    cb();\r\n                } else {\r\n                    window.requestAnimationFrame(draw);\r\n                }\r\n            }\r\n        }\r\n\r\n        function random(min, max) {\r\n            return parseInt(Math.random() * (max + 1 - min), 10) + min;\r\n        }\r\n        function shuffle(array) {\r\n            let currentIndex = array.length, temporaryValue, randomIndex;\r\n            while (currentIndex) {\r\n                randomIndex = Math.floor(Math.random() * currentIndex);\r\n                currentIndex -= 1;\r\n                temporaryValue = array[currentIndex];\r\n                array[currentIndex] = array[randomIndex];\r\n                array[randomIndex] = temporaryValue;\r\n            }\r\n            return array;\r\n        }\r\n\r\n        //generate final position and angle of rags\r\n        function getRagsFinalState() {\r\n            rags.forEach((v, i) => {\r\n                const finalAngle = (((Math.random() * maxAngle * 2) - maxAngle) / ((Math.random() + 2) * v.width)) * 10;\r\n\r\n                //coordinate based on center point\r\n                let x = v.left + v.width / 2 - w / 2;\r\n                let y = v.top + v.width / 2 - h / 2;\r\n\r\n                if (x === 0) {\r\n                    x = i % 2 ? -1 : 1;\r\n                }\r\n                if (y === 0) {\r\n                    y = (i % 4 < 2) ? -1 : 1;\r\n                }\r\n\r\n                const distance = Math.sqrt(x * x + y * y);\r\n\r\n\r\n                let ratio = ((1 - startRatio) * (1 - (v.width - minWidth) / (maxWidth - minWidth)) + startRatio) * Math.random();\r\n                ratio = 1 - (1 - ratio) * (1 - minRadius / radius);\r\n\r\n                const finalDistance = (radius - distance) * ratio + distance;\r\n                const distanceSquare = distance * distance;\r\n\r\n                const attach = {\r\n                    finalDistance,\r\n                    ratio,\r\n                    x,\r\n                    y,\r\n                    distance,\r\n                    translateX: (finalDistance - distance) * Math.sqrt((distanceSquare - y * y) / (distanceSquare)) * (x > 0 ? 1 : -1),\r\n                    translateY: (finalDistance - distance) * Math.sqrt((distanceSquare - x * x) / (distanceSquare)) * (y > 0 ? 1 : -1),\r\n                    translateX0: (ctxWidth - w) / 2 + v.left + v.width / 2,\r\n                    translateY0: (ctxHeight - h) / 2 + v.top + v.height / 2,\r\n                    finalAngle,\r\n                    finalAngleRad: finalAngle * (Math.PI / 180),\r\n                };\r\n\r\n                for (let i in attach) {\r\n                    v[i] = attach[i];\r\n                }\r\n\r\n            });\r\n        }\r\n        //generate inital position and dimension of rags\r\n        //rewrite it to fit for you demand\r\n        function generateRags() {\r\n            let rowCnt;\r\n            const base = [[0, 1], [1, 1], [1, 0], [0, 0]];\r\n            if (omitLastLine) {\r\n                rowCnt = Math.floor(h / maxWidth);\r\n            } else {\r\n                rowCnt = Math.ceil(h / maxWidth);\r\n            }\r\n\r\n            const rags = [];\r\n\r\n            const noRadius = radiusData.every(function (v) {\r\n                return v === 0;\r\n            });\r\n\r\n            for (let row = 0; row < rowCnt; row++) {\r\n                generateRow(row);\r\n            }\r\n\r\n            function isInner(x, y) {\r\n                if (x < radiusData[0] && y > h - radiusData[0] ||\r\n                    x > w - radiusData[1] && y > h - radiusData[1] ||\r\n                    x > w - radiusData[2] && y < radiusData[2] ||\r\n                    x < radiusData[3] && y < radiusData[3]) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n\r\n            function distanceLessThan(x1, y1, x2, y2, d) {\r\n                return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) < d * d;\r\n            }\r\n\r\n\r\n            function tryPushRag({\r\n                left,\r\n                top,\r\n                width,\r\n                height\r\n            }) {\r\n                const x = left + width / 2;\r\n                const y = h - top - height / 2;\r\n\r\n                if (noRadius || isInner(x, y) || radiusData.some(function (v, i) {\r\n                    return distanceLessThan(x, y, base[i][0] * w + 2 * (0.5 - base[i][0]) * v, base[i][1] * h + 2 * (0.5 - base[i][1]) * v, v);\r\n                })) {\r\n                    rags.push({\r\n                        left,\r\n                        top,\r\n                        width,\r\n                        height\r\n                    });\r\n                }\r\n            }\r\n\r\n            function generateRow(row) {\r\n                let rowSum = 0;\r\n                const topBase = row * maxWidth;\r\n\r\n                function generate(width) {\r\n                    const left = rowSum;\r\n                    rowSum += width;\r\n                    tryPushRag({\r\n                        left,\r\n                        top: topBase,\r\n                        width,\r\n                        height: width,\r\n                    });\r\n                    if (fill) {\r\n                        for (let i = 1; i < parseInt(maxWidth / width); i++) {\r\n                            tryPushRag({\r\n                                left,\r\n                                top: topBase + i * width,\r\n                                width,\r\n                                height: width,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                let width;\r\n                do {\r\n                    if (width) {\r\n                        generate(width);\r\n                    }\r\n                    width = random(minWidth, maxWidth);\r\n                } while (w > rowSum + width);\r\n                if (w - rowSum >= minWidth) {\r\n                    generate(w - rowSum);\r\n                }\r\n            }\r\n            shuffle(rags);\r\n            return rags;\r\n        }\r\n        //get an array of 4 corners of radius        \r\n        function getRadiusData() {\r\n            let ret = [\"border-top-left-radius\", \"border-top-right-radius\", \"border-bottom-right-radius\", \"border-bottom-left-radius\"];\r\n            const width = $target.width();\r\n            ret = ret.map(function (key) {\r\n                let radius = $target.css(key);\r\n                if (radius.match(/px$/)) {\r\n                    return radius.match(/^\\d+/)[0] * 1;\r\n                } else if (radius.match(/%$/)) {\r\n                    return radius.match(/^\\d+/)[0] / 100 * width;\r\n                }\r\n                return radius;\r\n            });\r\n            ret = ret.map(function (radius) {\r\n                if (radius > width / 2) {\r\n                    radius = width / 2;\r\n                }\r\n                return radius;\r\n            });\r\n            return ret;\r\n        }\r\n    };\r\n})(window.jQuery||window.Zepto);"]},"metadata":{},"sourceType":"module"}